(*Anonymous Authors*)

(*--Dolev-Yao model Open Channels--*)
free c:channel. (*Public Channel between UAVs*)

free IDA:bitstring.
free IDB:bitstring.

free posA: bitstring [private].
weaksecret posA.
free posB: bitstring [private].
weaksecret posB.

(*--Types--*)
type host.
type alt.
type lon.
type lat.
type sk.
type ts.
type G [large,bounded].

(*--Shared Symmetric Key--*)
free sym: sk [private].

(*--Hosts--*)
free uav: host.

(* Auxiliary Functions *)
fun mul(G,G):G.
fun mul2(bitstring,G):G.
fun inverse_mod(G,G):G.
fun sub(G,G):G.
fun div(G,G):G.
fun cast2bs(G):bitstring.
fun bs2g(bitstring):G.
fun map(lat, lon, alt):bitstring.

fun exp(bitstring,G):G.
fun exp2(G,G):G.

fun hash(G):bitstring.

(* Symmetric Encryption *)
fun senc (bitstring, sk):bitstring.
reduc forall m:bitstring, k:sk; sdec(senc(m,k),k) = m.

(*Events*)
event acceptUAV(sk).
event termUAV(sk).

(*--Check timestamp freshness operation--*)
fun freshness(ts, bool): bool
reduc forall T: ts; freshness(T, true) = true
otherwise forall T: ts; freshness(T, false) = false.

(* Authentication *)
query x:sk; event(termUAV(x)) ==> event(acceptUAV(x)).

(* Test if posA is secret *)
query attacker(posA).
query attacker(posB).

(* UAV Server *)
let uavA () = 
  new o:G;  (*value: 1*)
  new ex:G; (*exponent value: 3*)
  new p:G;
  new q:G;
  new tA:ts;

  let n   = mul(p,q) in
  let fi  = mul(sub(p,o),sub(q,o)) in
  let e   = ex in
  let d   = inverse_mod(e,fi) in
  out(c, (n,e));

  event acceptUAV(sym);

  (* Preparation *)
  new latA: lat;
  new lonA: lon;
  new altA: alt;
  let posA  = map(latA, lonA, altA) in

  let ksj = exp(posA,d) in
  let tj = hash(ksj) in

  in(c, (yc_enc:bitstring, tB:ts, checkT:bool));

  if checkT = true then
    let yc_dec = bs2g(sdec(yc_enc,sym)) in
    let yS = exp2(yc_dec,d) in
  
    (* out(c, (yS, tj)). *)
    out(c, (senc(cast2bs(yS),sym), senc(tj,sym), tB, freshness(tA, true))).

(* UAV Client *)
let uavB () = 
  in(c, ((nS:G, eS:G)));

  (* Preparation *)
  new Rci:G;
  new latB: lat;
  new lonB: lon;
  new altB: alt;
  new tB: ts;
  let posB  = map(latB, lonB, altB) in

  let yC = mul2(posB, exp2(Rci,eS)) in
  
  out(c, (senc(cast2bs(yC),sym), tB, freshness(tB, true)));

  in(c, ((ys_enc:bitstring, tjS_enc:bitstring, tA:ts, checkT:bool)));

  if checkT = true then
    let ys = bs2g(sdec(ys_enc,sym)) in
    let tjS = sdec(tjS_enc,sym) in

    let kci = div(ys,Rci) in
    let ti = hash(kci) in

    if ti = tjS then
      event termUAV(sym).

let udca =
  ! (uavA() | uavB()).
  
process udca

(*--------------------------------------------------------------
Verification summary:

Weak secret posA is true.

Weak secret posB is true.

Query event(termUAV(x)) ==> event(acceptUAV(x)) is true.

Query not attacker(posA[]) is true.

Query not attacker(posB[]) is true.

-------------------------------------------------------------*)
